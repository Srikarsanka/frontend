<!DOCTYPE html>
<html lang="en">

<head>
      <meta charset="UTF-8" />
      <title>Socket.IO Chat + WebRTC Video</title>
      <style>
            body {
                  font-family: Arial, sans-serif;
            }

            #messages {
                  list-style-type: none;
                  padding: 0;
                  max-height: 200px;
                  overflow-y: auto;
                  border: 1px solid #ccc;
                  margin-bottom: 10px;
            }

            #messages li {
                  padding: 5px 10px;
            }

            #messages li:nth-child(odd) {
                  background: #eee;
            }

            video {
                  width: 45%;
                  margin: 10px;
                  border: 1px solid black;
            }
      </style>
</head>

<body>
      <label>Username: <input id="username" placeholder="Enter your name" /></label><br /><br />
      <ul id="messages"></ul>
      <input id="m" autocomplete="off" placeholder="Type a message..." />
      <button onclick="sendMessage()">Send</button>

      <h2>Video Chat</h2>
      <video id="localVideo" autoplay muted playsinline></video>
      <video id="remoteVideo" autoplay playsinline></video>

      <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

      <script>
            const socket = io('https://webrtc-backend-siqi.onrender.com');

            // --- Chat ---
            const messages = document.getElementById('messages');

            socket.on('chat message', function (data) {
                  console.log('ðŸ“¨ Chat message received:', data);
                  const li = document.createElement('li');
                  li.textContent = `${data.username}: ${data.message}`;
                  messages.appendChild(li);
                  messages.scrollTop = messages.scrollHeight;
            });

            function sendMessage() {
                  const input = document.getElementById('m');
                  const usernameInput = document.getElementById('username');
                  const username = usernameInput.value.trim() || 'Anonymous';

                  if (input.value.trim() !== '') {
                        socket.emit('chat message', {
                              username: username,
                              message: input.value
                        });
                        input.value = '';
                  }
            }

            // --- WebRTC ---
            const localVideo = document.getElementById('localVideo');
            const remoteVideo = document.getElementById('remoteVideo');

            let localStream;
            let peerConnection;

            const config = {
                  iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            };

            async function startLocalStream() {
                  try {
                        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                        localVideo.srcObject = localStream;
                        console.log('ðŸŽ¥ Local stream started');
                  } catch (error) {
                        console.error('âŒ Error accessing media devices:', error);
                  }
            }

            startLocalStream();

            function createPeerConnection() {
                  peerConnection = new RTCPeerConnection(config);
                  console.log('ðŸ› ï¸ PeerConnection created');

                  localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                        console.log(`ðŸ“¡ Track added: ${track.kind}`);
                  });

                  peerConnection.ontrack = event => {
                        console.log('ðŸ“¶ Remote track received');
                        remoteVideo.srcObject = event.streams[0];
                  };

                  peerConnection.onicecandidate = event => {
                        if (event.candidate) {
                              console.log('ðŸ“¤ Sending ICE candidate');
                              socket.emit('ice-candidate', event.candidate);
                        }
                  };

                  peerConnection.onconnectionstatechange = () => {
                        console.log('ðŸ”„ Connection state:', peerConnection.connectionState);
                  };
            }

            socket.on('offer', async (offer) => {
                  console.log('ðŸ“© Offer received');
                  if (!peerConnection) createPeerConnection();

                  try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                        console.log('âœ… Remote description set with offer');

                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);

                        socket.emit('answer', answer);
                        console.log('ðŸ“¤ Sent answer');
                  } catch (e) {
                        console.error('âŒ Error handling offer:', e);
                  }
            });

            socket.on('answer', async (answer) => {
                  console.log('ðŸ“¨ Answer received');
                  try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                        console.log('âœ… Remote description set with answer');
                  } catch (e) {
                        console.error('âŒ Error setting answer as remote description:', e);
                  }
            });

            socket.on('ice-candidate', async (candidate) => {
                  console.log('ðŸ“¨ ICE candidate received');
                  try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log('âœ… ICE candidate added');
                  } catch (e) {
                        console.error('âŒ Error adding ICE candidate:', e);
                  }
            });

            async function call() {
                  if (!peerConnection) createPeerConnection();

                  try {
                        const offer = await peerConnection.createOffer();
                        await peerConnection.setLocalDescription(offer);

                        console.log('ðŸ“¤ Sending offer');
                        socket.emit('offer', offer);
                  } catch (e) {
                        console.error('âŒ Error creating or sending offer:', e);
                  }
            }

            // Ensure only one initiates call
            let hasCalled = false;
            socket.on('user-connected', () => {
                  if (!hasCalled) {
                        hasCalled = true;
                        call();
                  }
            });

            socket.emit('user-connected');
      </script>
</body>

</html>